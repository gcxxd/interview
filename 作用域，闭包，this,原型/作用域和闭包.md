# 严格模式
+ 严格模式禁止自动的或隐式的创建全局变量
+ 严格模式中,eval函数在运行时有自己的作用域，其中的声明无法改变当前的作用域。
# 作用域
> 定义：被设计用来知道如何存储变量，如何可以方便的找到变量的一套规则就被称为作用域
## 编译原理（JS相关）
> 变量的赋值会进行两个操作，编译器会在当前的作用域中声明一个变量（之前没有声明过），运行时引擎会在作用域中查找该变量，如果找到就对该变量赋值。
> 当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头 （RHS）。
### 异常
> RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。
> 如果RHS查询到的变量进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。
> ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。

# 词法作用域
> 定义： 作用域共有两种主要的工作模型，大多数编程语言采用的词法作用域，是一套关于引擎如何寻找变量以及会在何处找到变量的规则。
> 特征: 定义过程发生在代码的书写阶段
> 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定
> 作用域查找会在找到第一个匹配的标识符时停止
> 全局变量会自动成为全局对象的属性
## 欺骗词法
+ eval接受字符串，并将其执行， 在非严格模式下，eval可以在运行期修改书写期的词法作用域。
+ with with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象 本身。

# 动态作用域
> 特征:动态作用域不关心函数和作用域是如何声名以及在何处声名，只关心他们从何处调用。
> 动态作用域的作用域链是基于调用栈的而不是基于代码中的作用域嵌套。

# 词法作用域和动态作用域之间的区别
> 词法作用域是在写代码或者是定义时确定的，而动态作用域是在运行时确定的。

# 函数作用域
> Javascript具有基于函数的作用域。
> 函数作用域的含义是属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。
> 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位 置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

# 函数
> 函数表达式是可以匿名的，函数声明不可以
> 始终给函数表达式一个名称是最佳实践
> 立即执行函数表达式
 + 传统立即执行函数
```
    (
      function a(){}
    )()
```
 + 现在流行的立即执行函数
```
    (function () {}())
```
## 立即执行函数用法，场景
> 立即执行函数的一个非常普遍的用法是把他们当作函数调用传参数进去
```
var a = 2;  
(function IIFE( global ) {  
    var a = 3;     console.log( a ); // 3     console.log( global.a ); // 2  
})( window );  
console.log( a ); // 2

```
> 立即执行函数另外一种用途，，倒置代码的运行顺序，将需要运行的函数放在第二位，在立即执行函数执行之后当作参数传递进去，在UMD（通用模块定义规范常用）
```
(function IIFE( def ) {     def( window ); })(function def( global ) {  
    var a = 3;     console.log( a ); // 3     console.log( global.a ); // 2  
});
```

# 提升

> 引擎会在解释运行js代码之前首先对其进行编译，编译阶段其中的一部分工作就是找到所有的函数，变量的声明，并用合适的作用域把他们关联起来。  
> 这个过程就好像变量和函数声明的语句从他们代码出现的位置被移动到了最上面，这个过程就叫做“提升”。
> 每个作用域内部都会进行提升。
> 函数声明会被提升，函数表达式不会。

## 各种提升
+ let 的「创建」过程被提升了，但是初始化没有提升。
+ var 的「创建」和「初始化」都被提升了。
+ function 的「创建」「初始化」和「赋值」都被提升了。

## 函数优先
> 函数声明，变量声明都会提升，但是函数会先于变量被提升。
> 重复的函数声明，后面声明的函数会覆盖之前生命的函数。

# 作用域闭包
> 闭包是基于词法作用域书写代码时所产生的自然结果。
> 闭包的产生定义: 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
## 闭包使用场景
> 在任何的异步或同步任务中，只要使用了回调函数，实际上就是在使用闭包。
> 从技术上来说闭包是发生在定义时的，在一个函数A声明时，他拥有涵盖其上层函数B内部作用域的闭包，在A词法作用域之外调用A时，依然能够获取B内部作用域内的（依然能持有对B内部作用域的引用），这个引用就叫做闭包。

## 模块
### 模块模式需要具备两个必要条件
 + 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块 实例）。 
 + 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并 且可以访问或者修改私有的状态。
 > 一个具有函数属性的对象并不是真正的模块，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。
### 模块模式另一个简单但强大的变化用法, 命名将要作为公共 API 返回的对象
> 通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修 改，包括添加或删除方法和属性，以及修改它们的值。
```
var foo = (function CoolModule(id) {     function change() {         // 修改公共 API         publicAPI.identify = identify2;     }  
    function identify1() {          console.log( id );     }  
    function identify2() {         console.log( id.toUpperCase() );     }  
    var publicAPI = {          change: change,         identify: identify1     };  
    return publicAPI; })( "foo module" );  
foo.identify(); // foo module foo.change(); foo.identify(); // FOO MODULE
```
