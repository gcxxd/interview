# this
## 特征
> this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。
> 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。

## this的作用域
> this在任何情况下都不指向函数的词法作用域
> 作用域"对象"无法通过js访问，它只存在于js引擎内部。
> this和词法作用域是无法混合查找使用的
## 在函数内部引用自身
> arguments.callee 函数自身名称

# this全面解析
## 调用位置
+ 调用位置
> 函数在代码中被调用的位置
+ 调用栈
> 为了到达当前位置所调用的所有函数

## 绑定规则

### 默认绑定(无法应用其他规则时的默认规则)
> 直接调用不带任何修饰的函数会使用默认绑定(使用严格模式，全局对象将无法使用默认绑定)

### 隐式绑定(当调用位置有上下文对象，或者被某个对象拥有或者包含时)
> 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象
> 对象属性引用链中只有最顶层（即 最后一层）会影响调用位置。
> 回调函数会丢失已经有的this绑定,转而去应用默认绑定规则。

### 显式绑定
> 利用call(), apply()可以显示的实现this绑定
+ 硬绑定
```
//在函数显示绑定的外围包裹一个函数
var bar = function() {
foo.call( obj );
};
```
在es5中内置了Function.prototype.bind方法，这个方法返回一个函数实例，其this值会被绑定到传给bind()函数的参数值

### new绑定
> new和call,apply无法一起使用
> 使用new来调用函数(即发生构造函数调用时)，会执行一下操作
+ 创建（即构造）一个全新的对象
+ 这个对象会执行[[原型]]的连接
+ 这个新对象会绑定到函数调用的this
+ 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象

### 绑定规则的优先级
+ 函数是否在new中调用 && this绑定的是新创建的对象 (new绑定)
+ 函数是否通过call,apply或者硬绑定调用 && this绑定的是传入的指定对象 (显示绑定)
+ 函数是否在某个上下文当中调用 && this绑定的是那个上下文对象 (隐式绑定)
+ 如果都不是的话，使用默认绑定。在严格模式下绑定到undefined,在非严格模式下绑定到全局对象

### 绑定例外
> 把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则.常见场景(使用apply展开数组)

### this词法
> 在es6中的箭头函数中的this不适用this的四条规则，而是根据外层作用域来决定this，会继承外层作用域的this.
> 箭头函数的绑定无法被修改。

### js中的构造函数
> 在js中，构造函数只是一些使用new操作符时被调用的函数，他们并不属于某个类，也不会实例化一个类，它只是被new操作符调用的普通函数。


