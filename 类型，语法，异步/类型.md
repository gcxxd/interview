# 类型
> js中有7中内置类型，number, string, boolean, object, null, undefined, Symbol(es6新增)
+ 函数对象的length属性是他参数的个数

## 值和类型
> js中的变量是没有类型的，只有值才有。
+ typeof 对于未声名的变量返回的也是undefined,，通过 typeof 的安全防范机制（阻止报错）来检查 undeclared 变量，有时是个不错的办法

## 数组
> 一个特别主义的点，如果字符串键值能被强制转换为10进制的话，它就会被当作索引来处理。

## 字符串
> 字符串与数组的区别，字符串是不可变的，即字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。

## 数字
> 在所有遵循IEEE754规范的语言里，浮点数都是不准确的（0.1+0.2 === 0.2 //false），在es6中的Number原型上新增了EPSILON属性（机器精度）,可以用Number.EPSILON来判断两个浮点数相等

## 特殊数值
> null 指空值或曾赋过值但是目前没有值
> undefined 指没有值或从未赋过。可以通过void运算符得到该值。
    
## 特殊的数字
> 如果数学运算的操作数不是数字类型（或者无法解析为常规的十进制或十六进制数字），就无法返回一个有效的数字，这种情况下返回值为 NaN。
+ NaN实际上可以理解为（无效/失败/坏数值）,NaN是一个特殊值，它和自身不相等（js中唯一一个不等于自身的值），无法直接比较，只能用isNaN()
+ 全局内置的isNaN()检查参数是否不是NaN也不是数字，实际上不准确，因为对于字符串来说它不是数字但是他也不是NaN，但是用isNaN()也会返回true
+ es6在Number上新增了isNaN方法，可以解决上述bug
+ JS中有+0和-0，加法和减法计算不会得到-0。将-0转换为字符串或JSON.stringfy会变成0，但是如果将字符串-0字符串转换或JSON.parse为数字得到的结果是准确的。-0和0怎么比较都相等
### 特殊灯饰
> es6中新增了Object.is(a, b)来判断两个值是否绝对相等，可以用来处理上述所有特殊情况

## 值和引用
> 基本类型的值都是通过值复制的方式来赋值或传递的，对象和函数总是通过引用复制的方式来赋值和传递.
> 我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。


