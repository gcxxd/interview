# 异步
> 程序中现在运行的部分和将来运行的部分之间的关系就是异步编程的核心
> 在任何时候，只要把一段代码包装成一个函数，并指定他在响应某个事件时执行，就是在代码中创建了一个将来执行的块，也由此在这个程序中引入了异步机制。

## console相关Tip
> 在某些情况下，某些浏览器并不会把传入的内容立即输出。原因：在许多程序中，I/O 是非常低速的阻塞部分。所以，（从页面 /UI 的角度来说）浏览器有可能后台异步处理控制台 的I/O 。
> 处理方式:如果遇到这种少见的情况，最好的选择是在 JavaScript 调试器中使用断点，而不要依赖控制台输出。次优的方案是把对象序列化到一个字符串中，以强制执行一次“快照”，比如通过 JSON.stringify(..)

# 事件循环
> js引擎时运行在宿主环境里的(浏览器,nodeJS),所有这些环境都提供了一种机制来处理程序中多个块的执行，且执行每块时调用js引擎，这种机制就叫做事件循环
> 即js引擎并没有时间的概念，它只是一个按需执行js代码的环境。js代码执行的调度总是由包含他的环境进行。
## 任务队列
> 任务分为同步任务和异步任务,同步任务一般直接进入主线程执行，异步任务会通过任务队列(Event Queue)的形式来进行协调。
> 主线程的任务执行完就会去任务队列（Event Queue）读取任务，推入主线程执行。这个过程的不断重复就是事件循环(Event Loop)
## 循环执行
> 在事件循环中每一次循环操作称为tick,每次tick的任务处理模型如下：
1. 在此次tick中选择最先进入队列的任务。如果有则执行一次。
2. 检查是否存在Microtasks,如果存在则不停执行，直至清空Mickotask Queue
3. 更新render
4. 主线程重复上述步骤
## 任务(task)
> 宏任务(macrotask)主要包含script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)
> 微任务(microtask)主要包含Promise、MutaionObserver、process.nextTick(Node.js 环境)
> settimeout/Promise等则称为任务源,而进入任务队列的则是由他们指定的具体任务。来自不同任务源的任务会进入不同的任务队列。（其中 setTimeout 与 setInterval 是同源的）！

## 完整运行
> 由于js的单线程特性，js函数的代码具有原子性。即程序的原子性指：整个程序中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。
> 原子性操作：原子性在一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。

## 运行的不确定性
> js中代码执行的不确定性是在函数顺序级别上，不是多线程情况下的语句顺序级别。
> 在js的特性中，这种函数顺序的不确定性就是通常所说的竞态条件。

## 并发

### 非交互
> 两个或多个“进程”在同一个程序内并发地交替运行它们的步骤 / 事件时，如果这些任务彼此不相关，就不一定需要交互,不需要交互的情况下程序执行中的不确定性是可以接受的
### 交互
> 并发的进程之间需要相互交互，从而可能产生竞态条件
### 协作
> 这里的目标是取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行。

## 任务
> 在es6中，有一个新的概念在事件循环队列之上，叫做任务队列。理解方式: 任务队列是挂在事件循环队列的每个tick之后的队列。在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新时间添加到事件循环队列里，而会在当前的tick队列的末尾增加一个新任务。(这就像是在说：“哦，这里还有一件事将来要做，但要确保在其他任何事情发生之前就完成它。”)
> 一个任务可能引起更多的任务被添加到同一个队列的末尾。（即任务队列可能无限循环）

## 语句顺序
> 代码中语句的顺序并不一定要与js引擎执行语句的顺序相同。
